## Summary

We chose this kata as a starting point since it contains a little bit of everything. Some I/O, manipulating data structures and becuase you can solve it by using many different approaches. I think this was a good choice, at least for me.

I've tried Prolog before. I've read papers, blog posts, tutorials and books about it. I've tried the route finding and ancestor exercises that everyone else has but by doing this kata. I quickly went from thinking I knew (roughly) what was going on to understanding that I didn't. All in order to end up here.

I'm slightly confused. Mostly because implementing the solution was a lot easier than I thought it'd be and because several things that ended up in code was things I thought "What the hell. It might work, I'll try." about. I've *never* had that happen to me before (not even in Perl).

Once I got used to thinking in terms of pattern matching and realizing that I can put a variable *anywhere* (well, mostly) it got a lot easier. I also struggled a bit with how to read rule definitions and I'm not sure I've got a grip on that yet. I can not, for example, write the process and process_stream rules from scratch. But know enough to modify them for my purposes without messing them up.

All in all. Prolog is kind of cool. I'll keep exploring it for a little while longer. There are several concepts that I need to learn more about. Cuts for example. I've got a theory about them and how I think they work, but I expect it to be far too simplistic. The same probably goes for unification.